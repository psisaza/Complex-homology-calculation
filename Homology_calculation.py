#!/usr/bin/env python
# coding: utf-8

# In[ ]:




# $$
# \def\CC{\bf C}
# \def\QQ{\bf Q}
# \def\RR{\bf R}
# \def\ZZ{\bf Z}
# \def\NN{\bf N}
# $$
# 
# The ring $AN$ is the base ring over which we are going to work.
# In fact, the ring that interest us is the ring
# $R_{a,b,m}=\mathbb{C}[t,s,u]/(t^a-1,s^b-1,u^m-1)$, but we work with
# $AN$ for practical reasons. We define another rings that we will use
# too, and lists of keys that will be used to store the data orderly.

# In[ ]:


ANs.<s>=QQ[]
ANt.<t>=QQ[]
ANu.<u>=QQ[]
ANtu.<t,u>=QQ[]
ANsu.<s,u>=QQ[]
ANst.<s,t>=QQ[]
AN.<t,s,u>=QQ[]
claves=[(s,t,u), (t,u),  (s,u), (s,t),(u,)]
anillos={(s,t,u):AN, (t,u):ANtu,  (s,u):ANsu, (s,t):ANst,(u,):ANu, (s,):ANs, (t,):ANt}

# In[ ]:


M=[FreeModule(AN,_) for _ in [8,23,25,12,3]]

# We start with the module $M_0$ of the $0$-cells; we define it
# as a free module for practical reasons, though it is not actually free.
# We name the elements of the generating system and distribute them according
# to the actions that act trivially upon them.
# 
# The module $M_0$ is generated by
# $R,P_1,\hat{P}_1,P_2,\hat{P}_2,Q_1,Q_2,\hat{R}$. In fact,
# 
# $$M_0=R_{a,b,m}\langle R\rangle\oplus R_{a,b,m}/(s-1)\langle P_1,\hat{P}_1\rangle\oplus R_{a,b,m}/(t-1)\langle P_2,\hat{P}_2\rangle\oplus R_{a,b,m}/(u-1)\langle Q_1,Q_2,\hat{R}\rangle$$
# 
# The dictionary **M0dic** assigns to each key the elements of the generating
# system upon which the variables appearing in the key do **NOT** act trivially.

# In[ ]:


M0=M[0]
R,P1,P1h,P2,P2h,Q1,Q2,Rh=M0.gens()
Mdic={(0,s,t,u):[R],(0,t,u):[P1,P1h],(0,s,u):[P2,P2h],(0,s,t):[Q1,Q2,Rh],(0,u):[]}
Ldic={}
i=0
for _ in claves:
    cl=tuple([0]+list(_))
    j=len(Mdic[cl])
    Ldic[cl]=range(i,i+j)
    i=i+j

# We do the same for the module $M_1$ :
# 
# The module $M_1$ is generated by
# $m,l,k,a_1,a_2,b_1,b_2,\hat{m},\hat{l},\hat{a}_1,\hat{a}_2,r,c_1,\hat{c}_1,p_1,c_2,\hat{c}_2,p_2,h_1,h_2,\hat{k},q_1,q_2$.
# In fact,
# 
# $$M_1=R_{a,b,m}\langle m,l,k,a_1,a_2,b_1,b_2,\hat{m},\hat{l},\hat{a}_1,\hat{a}_2,r\rangle\oplus R_{a,b,m}/(s-1)\langle c_1,\hat{c}_1,p_1\rangle\oplus R_{a,b,m}/(t-1)\langle c_2,\hat{c}_2,p_2\rangle\oplus R_{a,b,m}/(u-1)\langle h_1,h_2,\hat{k},q_1,q_2\rangle$$

# In[ ]:


M1=M[1]
m,l,k,a1,a2,b1,b2,mh,lh,a1h,a2h,r,c1,c1h,p1,c2,c2h,p2,h1,h2,kh,q1,q2=M1.gens()
Mdic.update({(1,s,t,u):[m,l,k,a1,a2,b1,b2,mh,lh,a1h,a2h,r], (1,t,u):[c1,c1h,p1], (1,s,u):[c2,c2h,p2], (1,s,t):[h1,h2,kh,q1,q2], (1,u):[]})
i=0
for _ in claves:
    cl=tuple([1]+list(_))
    j=len(Mdic[cl])
    Ldic[cl]=range(i,i+j)
    i=i+j

# Now we build the matrix for $\delta_1:M_1\to M_0$. We do this in such
# a way that later it will be easy to recover the matrices that we will
# need according to the isotropy of the generators.

# In[ ]:


imagenes={}
pr=(s,t,u)
mm=len(Mdic[tuple([1]+list(pr))])
imagenes[1,0,pr,(s,t,u)]=[(u*s-1)*R,(u*t-1)*R,(t-s)*R,M0(0),M0(0),-R,-R,M0(0),M0(0),M0(0),M0(0),R]
imagenes[1,0,pr,(t,u)]=[M0(0),M0(0),M0(0),P1,M0(0),M0(0),M0(0),M0(0),M0(0),P1h,M0(0),M0(0)]
imagenes[1,0,pr,(s,u)]=[M0(0),M0(0),M0(0),M0(0),P2,M0(0),M0(0),M0(0),M0(0),M0(0),P2h,M0(0)]
imagenes[1,0,pr,(s,t)]=[M0(0),M0(0),M0(0),-Q1,-Q2,Q1,Q2,(s-1)*Rh,(t-1)*Rh,-Rh,-Rh,-Rh]
imagenes[1,0,pr,(u,)]=mm*[M0(0)]
imagenes[1,0,pr]=[sum([_[i] for _ in [imagenes[1,0,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(t,u)
mm=len(Mdic[tuple([1]+list(pr))])
imagenes[1,0,pr,(s,t,u)]=mm*[M0(0)]
imagenes[1,0,pr,(t,u)]=[(t-1)*P1,(t-1)*P1h,P1-P1h]
imagenes[1,0,pr,(s,u)]=mm*[M0(0)]
imagenes[1,0,pr,(s,t)]=mm*[M0(0)]
imagenes[1,0,pr,(u,)]=mm*[M0(0)]
imagenes[1,0,pr]=[sum([_[i] for _ in [imagenes[1,0,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(s,u)
mm=len(Mdic[tuple([1]+list(pr))])
imagenes[1,0,pr,(s,t,u)]=mm*[M0(0)]
imagenes[1,0,pr,(t,u)]=mm*[M0(0)]
imagenes[1,0,pr,(s,u)]=[(s-1)*P2,(s-1)*P2h,P2-P2h]
imagenes[1,0,pr,(s,t)]=mm*[M0(0)]
imagenes[1,0,pr,(u,)]=mm*[M0(0)]
imagenes[1,0,pr]=[sum([_[i] for _ in [imagenes[1,0,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(s,t)
mm=len(Mdic[tuple([1]+list(pr))])
imagenes[1,0,pr,(s,t,u)]=mm*[M0(0)]
imagenes[1,0,pr,(t,u)]=mm*[M0(0)]
imagenes[1,0,pr,(s,u)]=mm*[M0(0)]
imagenes[1,0,pr,(s,t)]=[(t-s)*Q1,-(t-s)*Q2,(t-s)*Rh,Q1-Rh,Q2-Rh]
imagenes[1,0,pr,(u,)]=mm*[M0(0)]
imagenes[1,0,pr]=[sum([_[i] for _ in [imagenes[1,0,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(u,)
mm=len(Mdic[tuple([1]+list(pr))])
imagenes[1,0,pr,(s,t,u)]=mm*[M0(0)]
imagenes[1,0,pr,(t,u)]=mm*[M0(0)]
imagenes[1,0,pr,(s,u)]=mm*[M0(0)]
imagenes[1,0,pr,(s,t)]=mm*[M0(0)]
imagenes[1,0,pr,(u,)]=mm*[M0(0)]
imagenes[1,0,pr]=[sum([_[i] for _ in [imagenes[1,0,pr,cl] for cl in claves]]) for i in range(mm)]
imagenes[1,0]=flatten([imagenes[1,0,_] for _ in claves])
delta1=M1.hom(imagenes[1,0],M0)
A={}
A[1]=delta1.matrix()
A1=A[1]

# In[ ]:


show(A1)

# In[ ]:


latex(A1)

# In[ ]:


def varclave(tuplevar,clave):
    res=True
    for _ in tuplevar:
        res=res and _ in clave
    return res
tupleclaves=[(s,),(t,),(u,),(s,t),(t,u),(s,u),(s,t,u)]
clavevar={tuplevar:[_ for _ in claves if varclave(tuplevar,_)] for tuplevar in tupleclaves}

# In[ ]:


for pr in tupleclaves:
    clpr=clavevar[pr]
    sbs={vr:1 for vr in (s,t,u) if vr not in pr}
    pr0=flatten([Ldic[tuple([0]+list(_))] for _ in clpr])
    A[1,pr]=Matrix(flatten([imagenes[1,0,_] for _ in clpr])).matrix_from_columns(pr0).subs(sbs).change_ring(anillos[pr])

# We do the same for $M_2$ :
# 
# The module $M_2$ is generated by
# $\sigma, \pi, \theta_1, \theta_2, \omega_1, \omega_2, \phi_1, \phi_2, \hat{\sigma}, \hat{\pi}, \hat{\theta}_1, \hat{\theta}_2, \hat{\omega}_1, \hat{\omega}_2, \mu, \lambda, \kappa, \alpha_1, \alpha_2, \beta_1, \beta_2, \zeta_1, \zeta_2, \eta_1, \eta_2$.
# In fact,
# 
# $$M_2=R_{a,b,m}\langle \sigma, \pi, \theta_1, \theta_2, \omega_1, \omega_2, \phi_1, \phi_2, \hat{\sigma}, \hat{\pi}, \hat{\theta}_1, \hat{\theta}_2, \hat{\omega}_1, \hat{\omega}_2, \mu, \lambda, \kappa, \alpha_1, \alpha_2, \beta_1, \beta_2\rangle\oplus R_{a,b,m}/(s-1)\langle \zeta_1\rangle\oplus R_{a,b,m}/(t-1)\langle \zeta_2\rangle\oplus R_{a,b,m}/(u-1)\langle \eta_1, \eta_2\rangle$$

# In[ ]:


M2=M[2]
sigma,pi_0,theta_1,theta_2,omega_1,omega_2,phi_1,phi_2,sigmah,pi_0h,theta_1h,theta_2h,omega_1h,omega_2h,mu,lambda_0,kappa,alpha_1,alpha_2,beta_1,beta_2,zeta_1,zeta_2,eta_1,eta_2=M2.gens()
Mdic.update({(2,s,t,u):[sigma,pi_0,theta_1,theta_2,omega_1,omega_2,phi_1,phi_2, sigmah,pi_0h,theta_1h,theta_2h,omega_1h,omega_2h,mu,lambda_0,kappa,alpha_1,alpha_2,beta_1,beta_2], (2,t,u):[zeta_1], (2,s,u):[zeta_2], (2,s,t):[eta_1,eta_2], (2,u):[]})
i=0
for _ in claves:
    cl=tuple([2]+list(_))
    j=len(Mdic[cl])
    Ldic[cl]=range(i,i+j)
    i=i+j

# In[ ]:


pr=(s,t,u)
mm=len(Mdic[tuple([2]+list(pr))])
imagenes[2,1,pr,(s,t,u)]=[s*l-t*m-k, m+u*k-l, m+(s-1)*a1+(s*u-1)*b1, l+(t-1)*a2+(t*u-1)*b2,-l+(1-t)*a1+(1-t*u)*b1, -m+(1-s)*a2+(1-s*u)*b2, -k+(s-t)*b1, k-(s-t)*b2, s*lh-t*mh, mh-lh, mh+(s-1)*a1h, lh+(t-1)*a2h, -lh+(1-t)*a1h, -mh+(1-s)*a2h, (u*s-1)*r+mh-m, (u*t-1)*r+lh-l, (t-s)*r-k,a1h-a1, a2h-a2, -r-b1, -r-b2]
imagenes[2,1,pr,(t,u)]=[M1(0),M1(0),M1(0),M1(0),c1,M1(0),M1(0),M1(0),M1(0),M1(0),M1(0),M1(0),c1h,M1(0),M1(0),M1(0),M1(0),p1,M1(0),M1(0),M1(0)]
imagenes[2,1,pr,(s,u)]=[M1(0),M1(0),M1(0),M1(0),M1(0),c2,M1(0),M1(0),M1(0),M1(0),M1(0),M1(0),M1(0),c2h,M1(0),M1(0),M1(0),M1(0),p2,M1(0),M1(0)]
imagenes[2,1,pr,(s,t)]=[M1(0),M1(0),M1(0),M1(0),M1(0),M1(0),h1,h2,-kh,u*kh,M1(0),M1(0),M1(0),M1(0),M1(0),M1(0),kh,-q1,-q2,q1,q2]
imagenes[2,1,pr,(u,)]=mm*[M1(0)]
imagenes[2,1,pr]=[sum([_[i] for _ in [imagenes[2,1,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(t,u)
mm=len(Mdic[tuple([2]+list(pr))])
imagenes[2,1,pr,(s,t,u)]=mm*[M1(0)]
imagenes[2,1,pr,(t,u)]=[(t-1)*p1+c1h-c1]
imagenes[2,1,pr,(s,u)]=mm*[M1(0)]
imagenes[2,1,pr,(s,t)]=mm*[M1(0)]
imagenes[2,1,pr,(u,)]=mm*[M1(0)]
imagenes[2,1,pr]=[sum([_[i] for _ in [imagenes[2,1,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(s,u)
mm=len(Mdic[tuple([2]+list(pr))])
imagenes[2,1,pr,(s,t,u)]=mm*[M1(0)]
imagenes[2,1,pr,(t,u)]=mm*[M1(0)]
imagenes[2,1,pr,(s,u)]=[(s-1)*p2+c2h-c2]
imagenes[2,1,pr,(s,t)]=mm*[M1(0)]
imagenes[2,1,pr,(u,)]=mm*[M1(0)]
imagenes[2,1,pr]=[sum([_[i] for _ in [imagenes[2,1,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(s,t)
mm=len(Mdic[tuple([2]+list(pr))])
imagenes[2,1,pr,(s,t,u)]=mm*[M1(0)]
imagenes[2,1,pr,(t,u)]=mm*[M1(0)]
imagenes[2,1,pr,(s,u)]=mm*[M1(0)]
imagenes[2,1,pr,(s,t)]=[(t-s)*q1+kh-h1,-(t-s)*q2-kh-h2]
imagenes[2,1,pr,(u,)]=mm*[M1(0)]
imagenes[2,1,pr]=[sum([_[i] for _ in [imagenes[2,1,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(u,)
mm=len(Mdic[tuple([2]+list(pr))])
imagenes[2,1,pr,(s,t,u)]=mm*[M1(0)]
imagenes[2,1,pr,(t,u)]=mm*[M1(0)]
imagenes[2,1,pr,(s,u)]=mm*[M1(0)]
imagenes[2,1,pr,(s,t)]=mm*[M1(0)]
imagenes[2,1,pr,(u,)]=mm*[M1(0)]
imagenes[2,1,pr]=[sum([_[i] for _ in [imagenes[2,1,pr,cl] for cl in claves]]) for i in range(mm)]
imagenes[2,1]=flatten([imagenes[2,1,_] for _ in claves])
delta2=M2.hom(imagenes[2,1],M1)
A[2]=delta2.matrix()
A2=A[2]

# In[ ]:


show(A2)

# In[ ]:


latex(A2)

# In[ ]:


for pr in tupleclaves:
    clpr=clavevar[pr]
    sbs={vr:1 for vr in (s,t,u) if vr not in pr}
    pr0=flatten([Ldic[tuple([1]+list(_))] for _ in clpr])
    A[2,pr]=Matrix(flatten([imagenes[2,1,_] for _ in clpr])).matrix_from_columns(pr0).subs(sbs).change_ring(anillos[pr])

# The module $M_3$ is generated by
# $\Psi_1,\Psi_2,\hat{\Psi}_1,\hat{\Psi}_2,\Theta_1,\Theta_2,\Omega_1,\Omega_2,\Phi_1,\Phi_2,\Sigma,\Pi$
# and is free.

# In[ ]:


M3=M[3]
Psi_1,Psi_2,Psi_1h,Psi_2h,Theta_1,Theta_2,Omega_1,Omega_2,Phi_1,Phi_2,Sigma_0,Pi_0=M3.gens()
Mdic.update({(3,s,t,u):[Psi_1,Psi_2,Psi_1h,Psi_2h,Theta_1,Theta_2,Omega_1,Omega_2,Phi_1,Phi_2,Sigma_0,Pi_0], (3,t,u):[], (3,s,u):[], (3,s,t):[], (3,u):[]})
i=0
for _ in claves:
    cl=tuple([3]+list(_))
    j=len(Mdic[cl])
    Ldic[cl]=range(i,i+j)
    i=i+j

# In[ ]:


pr=(s,t,u)
mm=len(Mdic[tuple([3]+list(pr))])
imagenes[3,2,pr,(s,t,u)]=[sigma+pi_0+(t-1)*theta_1+(s-1)*omega_1+(u-1)*phi_1,-sigma-pi_0+(s-1)*theta_2+(t-1)*omega_2+(u-1)*phi_2,sigmah+pi_0h+(t-1)*theta_1h+(s-1)*omega_1h,-sigmah-pi_0h+(s-1)*theta_2h+(t-1)*omega_2h,mu+(s-1)*alpha_1+(s*u-1)*beta_1+theta_1-theta_1h,lambda_0+(t-1)*alpha_2+(t*u-1)*beta_2+theta_2-theta_2h,-lambda_0+(1-t)*alpha_1+(1-t*u)*beta_1+omega_1-omega_1h,-mu+(1-s)*alpha_2+(1-s*u)*beta_2+omega_2-omega_2h,-kappa+(s-t)*beta_1+phi_1, kappa-(s-t)*beta_2+phi_2,s*lambda_0-t*mu-kappa+sigma-sigmah,mu+u*kappa-lambda_0+pi_0-pi_0h]
imagenes[3,2,pr,(t,u)]=[M2(0),M2(0),M2(0),M2(0),M2(0),M2(0),zeta_1,M2(0),M2(0),M2(0),M2(0),M2(0)]
imagenes[3,2,pr,(s,u)]=[M2(0),M2(0),M2(0),M2(0),M2(0),M2(0),M2(0),zeta_2,M2(0),M2(0),M2(0),M2(0)]
imagenes[3,2,pr,(s,t)]=[M2(0),M2(0),M2(0),M2(0),M2(0),M2(0),M2(0),M2(0),eta_1,eta_2,M2(0),M2(0)]
imagenes[3,2,pr,(u,)]=mm*[M2(0)]
imagenes[3,2,pr]=[sum([_[i] for _ in [imagenes[3,2,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(t,u)
mm=len(Mdic[tuple([3]+list(pr))])
imagenes[3,2,pr,(s,t,u)]=mm*[M2(0)]
imagenes[3,2,pr,(t,u)]=mm*[M2(0)]
imagenes[3,2,pr,(s,u)]=mm*[M2(0)]
imagenes[3,2,pr,(s,t)]=mm*[M2(0)]
imagenes[3,2,pr,(u,)]=mm*[M2(0)]
imagenes[3,2,pr]=[sum([_[i] for _ in [imagenes[3,2,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(s,u)
mm=len(Mdic[tuple([3]+list(pr))])
imagenes[3,2,pr,(s,t,u)]=mm*[M2(0)]
imagenes[3,2,pr,(t,u)]=mm*[M2(0)]
imagenes[3,2,pr,(s,u)]=mm*[M2(0)]
imagenes[3,2,pr,(s,t)]=mm*[M2(0)]
imagenes[3,2,pr,(u,)]=mm*[M2(0)]
imagenes[3,2,pr]=[sum([_[i] for _ in [imagenes[3,2,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(s,t)
mm=len(Mdic[tuple([3]+list(pr))])
imagenes[3,2,pr,(s,t,u)]=mm*[M2(0)]
imagenes[3,2,pr,(t,u)]=mm*[M2(0)]
imagenes[3,2,pr,(s,u)]=mm*[M2(0)]
imagenes[3,2,pr,(s,t)]=mm*[M2(0)]
imagenes[3,2,pr,(u,)]=mm*[M2(0)]
imagenes[3,2,pr]=[sum([_[i] for _ in [imagenes[3,2,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(u,)
mm=len(Mdic[tuple([3]+list(pr))])
imagenes[3,2,pr,(s,t,u)]=mm*[M2(0)]
imagenes[3,2,pr,(t,u)]=mm*[M2(0)]
imagenes[3,2,pr,(s,u)]=mm*[M2(0)]
imagenes[3,2,pr,(s,t)]=mm*[M2(0)]
imagenes[3,2,pr,(u,)]=mm*[M2(0)]
imagenes[3,2,pr]=[sum([_[i] for _ in [imagenes[3,2,pr,cl] for cl in claves]]) for i in range(mm)]
imagenes[3,2]=flatten([imagenes[3,2,_] for _ in claves])
delta3=M3.hom(imagenes[3,2],M2)
A[3]=delta3.matrix()
A3=A[3]

# In[ ]:


show(A3)

# In[ ]:


latex(A3)

# In[ ]:


for pr in tupleclaves:
    clpr=clavevar[pr]
    sbs={vr:1 for vr in (s,t,u) if vr not in pr}
    pr0=flatten([Ldic[tuple([2]+list(_))] for _ in clpr])
    A[3,pr]=Matrix(flatten([imagenes[3,2,_] for _ in clpr])).matrix_from_columns(pr0).subs(sbs).change_ring(anillos[pr])

# The last module, $M_4$, is generated by $\Xi_1,\Xi_2,\Upsilon$ :
# 
# $$M_4=R_{a,b,c}\langle\Xi_1,\Xi_2\rangle\oplus R_{a,b,c}/(t-1,s-1)\langle\Upsilon\rangle$$
# 
# In this case we don't insert the differential correctly because it involves
# a polynomial on $a,b$. In fact,
# 
# $$\partial_4(\Upsilon)=\frac{(t^a-1)(s^b-1)}{(t-1)(s-1)}\left(\hat{\Psi}_1+\hat{\Psi}_2\right)$$

# In[ ]:


M4=M[4]
Xi_1,Xi_2,Upsilon=M4.gens()
Mdic.update({(4,s,t,u):[Xi_1,Xi_2], (4,t,u):[], (4,s,u):[], (4,s,t):[], (4,u):[Upsilon]})
i=0
for _ in claves:
    cl=tuple([4]+list(_))
    j=len(Mdic[cl])
    Ldic[cl]=range(i,i+j)
    i=i+j

# In[ ]:


pr=(s,t,u)
mm=len(Mdic[tuple([4]+list(pr))])
imagenes[4,3,pr,(s,t,u)]=[Sigma_0+Pi_0+(t-1)*Theta_1+(s-1)*Omega_1+(u-1)*Phi_1-Psi_1+Psi_1h,-Sigma_0-Pi_0+(s-1)*Theta_2+(t-1)*Omega_2+(u-1)*Phi_2-Psi_2+Psi_2h]
imagenes[4,3,pr,(t,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,t)]=mm*[M3(0)]
imagenes[4,3,pr,(u,)]=mm*[M3(0)]
imagenes[4,3,pr]=[sum([_[i] for _ in [imagenes[4,3,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(t,u)
mm=len(Mdic[tuple([4]+list(pr))])
imagenes[4,3,pr,(s,t,u)]=mm*[M3(0)]
imagenes[4,3,pr,(t,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,t)]=mm*[M3(0)]
imagenes[4,3,pr,(u,)]=mm*[M3(0)]
imagenes[4,3,pr]=[sum([_[i] for _ in [imagenes[4,3,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(s,u)
mm=len(Mdic[tuple([4]+list(pr))])
imagenes[4,3,pr,(s,t,u)]=mm*[M3(0)]
imagenes[4,3,pr,(t,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,t)]=mm*[M3(0)]
imagenes[4,3,pr,(u,)]=mm*[M3(0)]
imagenes[4,3,pr]=[sum([_[i] for _ in [imagenes[4,3,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(s,t)
mm=len(Mdic[tuple([4]+list(pr))])
imagenes[4,3,pr,(s,t,u)]=mm*[M3(0)]
imagenes[4,3,pr,(t,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,t)]=mm*[M3(0)]
imagenes[4,3,pr,(u,)]=mm*[M3(0)]
imagenes[4,3,pr]=[sum([_[i] for _ in [imagenes[4,3,pr,cl] for cl in claves]]) for i in range(mm)]
pr=(u,)
mm=len(Mdic[tuple([4]+list(pr))])
imagenes[4,3,pr,(s,t,u)]=[Psi_1h+Psi_2h]
imagenes[4,3,pr,(t,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,u)]=mm*[M3(0)]
imagenes[4,3,pr,(s,t)]=mm*[M3(0)]
imagenes[4,3,pr,(u,)]=mm*[M3(0)]
imagenes[4,3,pr]=[sum([_[i] for _ in [imagenes[4,3,pr,cl] for cl in claves]]) for i in range(mm)]
imagenes[4,3]=flatten([imagenes[4,3,_] for _ in claves])
delta4=M4.hom(imagenes[4,3],M3)
A[4]=delta4.matrix()
A4=A[4]

# In[ ]:


for pr in tupleclaves:
    clpr=clavevar[pr]
    sbs={vr:1 for vr in (s,t,u) if vr not in pr}
    pr0=flatten([Ldic[tuple([3]+list(_))] for _ in clpr])
    A[4,pr]=Matrix(flatten([imagenes[4,3,_] for _ in clpr])).matrix_from_columns(pr0).subs(sbs).change_ring(anillos[pr])

# In[ ]:


#P=AN((t^var_a-1)*(s^var_b-1)/(t-1)/(s-1))

# In[ ]:


for j in [1..4]:
    A[j,()]=A[j](t=1,s=1,u=1).change_ring(QQ)

# In the following cell we have the dimensions of the matrices of the
# differentials in the case $(\zeta,\xi,\mu)=(1,1,1)$.
# 
# > $\dim C_0=8,\dots,\dim C_4=3$

# In[ ]:


for j in [1..4]:
    print A[j,()].dimensions()

# In the following cell we have the ranks of the matrices: 7,16,9,3

# In[ ]:


k=A[1,()].ncols()
for j in [1,2,3,4]:
    mat=A[j,()]
    #print "Rango de C",0,":",mat.ncols()
    print "Rango del ker de delta",j-1,":",k
    print "Rango de la imagen de delta",j,":",mat.rank()
    k=mat.nrows()-mat.rank()

# In[ ]:


[(mat.rank(),mat.ncols()) for mat in [A[j,()] for j in [4,3,2,1]]]

# The following cell examines the $(\zeta,\xi,\mu)=(\zeta,1,1)$, with
# $\zeta\neq 1$.
# 
# In this case $\dim C_j=6,20,24,12,2$ for $j=0,\dots,4$
# 
# Here we interpret the matrices of $\delta_j$ as having values in
# $\mathbb{C}[s]$.
# 
# The results below state that the ranks of these matrices are:
# $6,14,12,2$, independently of the value of $s\neq 1$.
# 
# Therefore, the dimensions of the kernels are: $14,10,2,0$.

# In[ ]:


pr=(s,)
Maux=[A[_,pr] for _ in [4,3,2,1]]
Saux=[mat.smith_form() for mat in Maux]
for mat in Saux:
    aux=[mat[0][j,j] for j in range(min(mat[0].dimensions()))]
    print aux,len([_ for _ in aux if _!=0]),mat[0].dimensions()

# Similarly for $(\zeta,\xi,\mu)=(1,\xi,1)$, with $\xi\neq 1$.

# In[ ]:


pr=(t,)
Maux=[A[_,pr] for _ in [4,3,2,1]]
Saux=[mat.smith_form() for mat in Maux]
for mat in Saux:
    aux=[mat[0][j,j] for j in range(min(mat[0].dimensions()))]
    print aux,len([_ for _ in aux if _!=0]),mat[0].dimensions()

# The following cell examines the $(\zeta,\xi,\mu)=(1,1,\mu)$, with
# $\mu\neq 1$.
# 
# In this case $\dim C_j=5,18,23,12,3$ for $j=0,\dots,4$
# 
# Here we interpret the matrices $\delta_j$ as having values in
# $\mathbb{C}[u]$.
# 
# The results below state that the ranks of these matrices are:
# $5,13,9,3$, independently of the value of $s\neq 1$.
# 
# Therefore, the dimensions of the kernels are: $13,10,3,0$.
# 
# For this sequence all the homology groups but $H_2$ are trivial. Since
# this happens for $m-1$ roots of unity, we have found an $m-1$-dimensional
# subspace of $H_2$.

# In[ ]:


pr=(u,)
Maux=[A[_,pr] for _ in [4,3,2,1]]
Saux=[mat.smith_form() for mat in Maux]
for mat in Saux:
    aux=[mat[0][j,j] for j in range(min(mat[0].dimensions()))]
    print aux,len([_ for _ in aux if _!=0]),mat[0].dimensions()

# In[ ]:


def smith2(A):
    dg=[]
    pvt=True
    B=copy(A)
    while pvt and min(B.dimensions())>=0:
        U=B.list()
        U0=[v.degree()==0 for v in U]
        pvt=not prod([not v for v in U0])
        if not pvt:
            return [dg,B]
        k=ZZ(U0.index(True))
        i,j=k.quo_rem(B.ncols())
        B.swap_rows(0,i)
        B.swap_columns(0,j)
        for i in range(1,B.nrows()):
            B.add_multiple_of_row(i,0,-B[i,0]/B[0,0])
        for j in range(1,B.ncols()):
            B.add_multiple_of_column(j,0,-B[0,j]/B[0,0])
        dg.append(B[0,0])
        B=B.delete_rows([0]).delete_columns([0])

# In[ ]:


def smith2var(A,pr):
    dg,B=smith2(A)
    an=anillos[pr]
    for i in range(B.nrows()):
        Bi=B[i]
        mcd=gcd(Bi.list())
        for vv in pr:
            if an(vv-1).divides(mcd):
                Bi1=Bi.change_ring(an.fraction_field())
                Bi2=Bi1/an(vv-1)
                Bi=Bi2.change_ring(an)
        B[i]=Bi
    for i in range(B.ncols()):
        Bi=B.column(i)
        mcd=gcd(Bi.list())
        for vv in pr:
            if an(vv-1).divides(mcd):
                Bi1=Bi.change_ring(an.fraction_field())
                Bi2=Bi1/an(vv-1)
                Bi=Bi2.change_ring(an)
        for j in range(B.nrows()):
            B[j,i]=Bi[j]
    dg1,B1=smith2(B)
    return dg+dg1,B1

# The following cell examines the $(\zeta,\xi,\mu)=(\zeta,\xi,1)$, with
# $\zeta,\xi\neq 1$.
# 
# In this case $\dim C_j=4,17,23,12,2$ para $j=0,\dots,4$
# 
# Here we interpret the matrices $\delta_j$ as having values in
# $\mathbb{C}[s,t]$ for which the Smith form does not necessarily exists,
# but we can apply elementary operations.
# 
# The results below state that the ranks of these matrices are:
# $4,13,10,2$, independently of the value of $s,t\neq 1$.
# 
# Something similar happens for the cases $(\zeta,\xi,\mu)=(\zeta,1,\mu)$, with
# $\zeta,\mu\neq 1$ and $(\zeta,\xi,\mu)=(1,\xi,\mu)$, with $\xi,\mu\neq 1$.

# In[ ]:


pr=(s,t)
Maux=[A[_,pr] for _ in [1..4]]
for i in [1..4]:
    n0,m0=Maux[i-1].dimensions()
    print "*******************************"
    dg,SM=smith2(Maux[i-1])
    dg1,SM1=smith2var(SM,pr)
    print "Rango de M",i-1,": ",m0
    print "Rango de M",i,": ",n0
    print "diagonalizado en delta",i,": ",dg+dg1,len(dg+dg1)
    if SM1!=0:
        print "parte no diagonalizada de delta",i,": ",show(SM1)
    print "*******************************"
    print "\n"

# In[ ]:


pr=(s,u)
Maux=[A[_,pr] for _ in [1..4]]
for i in [1..4]:
    n0,m0=Maux[i-i].dimensions()
    print "*******************************"
    dg,SM=smith2(Maux[i-1])
    dg1,SM1=smith2var(SM,pr)
    print "Rango de M",i-1,": ",m0
    print "Rango de M",i,": ",n0
    print "diagonalizado en delta",i,": ",dg+dg1,len(dg+dg1)
    if SM1!=0:
        print "parte no diagonalizada de delta",i,": ",show(SM1)
    print "*******************************"
    print "\n"

# In[ ]:


pr=(t,u)
Maux=[A[_,pr] for _ in [1..4]]
for i in [1..4]:
    n0,m0=Maux[i-i].dimensions()
    print "*******************************"
    dg,SM=smith2(Maux[i-1])
    dg1,SM1=smith2var(SM,pr)
    print "Rango de M",i-1,": ",m0
    print "Rango de M",i,": ",n0
    print "diagonalizado en delta",i,": ",dg+dg1,len(dg+dg1)
    if SM1!=0:
        print "parte no diagonalizada de delta",i,": ",show(SM1)
    print "*******************************"
    print "\n"-1, -1, -1, -1

# The following cell examines the $(\zeta,\xi,\mu)=(\zeta,\xi,\mu)$, with
# $\zeta,\xi,\mu\neq 1$.
# 
# In this case $\dim C_j=1,12,21,12,2$ para $j=0,\dots,4$
# 
# Here we interpret the matrices $\delta_j$ as having values in
# $\mathbb{C}[s,t,u]$ for which the Smith form does not necessarily exists,
# # but we can apply elementary operations.
# 
# The results below state that the ranks of these matrices are:
# $\delta_1:1$, 4, $\delta_3:3$, $\delta_4:2$, independently of
# the value of $s,t,u\neq 1$. But $\delta_2$ has rank 10 if $t=s$ and rank
# 11 if $t\neq s$. This happens in $(d-1)(m-1)$ cases, $d=\gcd(a,b)$.
# 
# It can be calculated that $H_2,H_1$ has rank $1$ if $s=t$; and zero
# in any other case.

# In[ ]:


pr=(s,t,u)
Maux=[A[_,pr] for _ in [1..4]]
for i in [1..4]:
    n0,m0=Maux[i-1].dimensions()
    print "*******************************"
    dg,SM=smith2(Maux[i-1])
    dg1,SM1=smith2var(SM,pr)
    print "Rango de M",i-1,": ",m0
    print "Rango de M",i,": ",n0
    print "diagonalizado en delta",i,": ",dg+dg1,len(dg+dg1)
    if SM1!=0:
        print "parte no diagonalizada de delta",i,": "
        show(SM1)
    print "*******************************"
    print "\n"
